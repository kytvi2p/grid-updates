#!/bin/sh

# grid-updates -- a helper script for a Tahoe-LAFS nodes
#
#
# Authors:
#     darrob <darrob@mail.i2p>
#     KillYourTV <kytv@mail.i2p>
#
# License: public domain
#
# Requirements:
#     Bourne-compatible shell, Tahoe-LAFS

# For more information see the README.md and INSTALL.md files.

# This script's version:
VERSION='0.2-git'

############################### Configuration #################################
# Default location of the Tahoe-LAFS node:
#TAHOE_NODE_DIR="$HOME/.tahoe"
# Default location (directory) of the subscription list:
LISTURI='URI:DIR2-RO:22s6zidugdxaeikq6lakbxbcci:mgrc3nfnygslyqrh7hds22usp6hbn3pulg5bu2puv6y3wpoaaqqq'
# Default location (directory) of the NEWS file:
NEWSURI='URI:DIR2-RO:vi2xzmrimvcyjdoypphdwxqbte:g7lpf2v6vyvl4w5udgpriiawg6ofmbazktvxmspesvkqtmujr2rq/Latest'
# Default location (directory) of script releases:
SCRIPTURI='URI:DIR2-RO:mjozenx3522pxtqyruekcx7mh4:eaqgy2gfsb73wb4f4z2csbjyoh7imwxn22g4qi332dgcvfyzg73a'
###############################################################################

only_verbose () {
	if [ $OPT_VERBOSE ]; then
		$@
	fi
}

# Stop multiple instances from running simultaneously
if [ -w /var/lock ]; then  # the default lock directory in Linux
        LOCKDIR="/var/lock/grid-updates.lck"
else
        LOCKDIR="/tmp/grid-updates.lck"   # but maybe not elsewhere...
fi
PIDFILE="${LOCKDIR}/PID"
ENO_SUCCESS=0;
ENO_GENERAL=1;
ENO_LOCKFAIL=2;
ENO_RECVSIG=3;

if mkdir "${LOCKDIR}"  > /dev/null 2>&1 ; then
       trap 'ECODE=$?;
       rm -rf "${LOCKDIR}"' 0
       touch $PIDFILE
       echo $$ > "${PIDFILE}"
       trap 'echo "ERROR: Killed by a signal $ECODE $ENO_RECVSIG" >&2
            exit ${ENO_RECVSIG}' 1 2 3 15
else
       # lock failed, check if it's stale
       OTHERPID="$(cat "${PIDFILE}")"

       if [ $? != 0 ]; then
               echo "ERROR: Another instance of `basename $0` is active with PID ${OTHERPID}" >&2
               exit ${ENO_LOCKFAIL}
       fi

       if ! kill -0 ${OTHERPID} >/dev/null 2>&1; then
               #stale lock, removing it and restarting
               only_verbose echo "INFO: Removing stale PID ${OTHERPID}" >&2
               rm -rf ${LOCKDIR} || echo "Cannot remove $LOCKDIR" >&2; exit 1
               only_verbose echo "INFO: [`basename $0`] restarting" >&2
               exec "$0" "$@"
       else
               #lock is valid and OTHERPID is active
               echo "ERROR: Another instance of `basename $0` is active with PID ${OTHERPID}" >&2
               exit ${ENO_LOCKFAIL}
       fi
fi

print_help () {
cat << EOF

Usage: $0 [OPTIONS] [ACTION]

Actions:
    -m, --merge-introducers     Merge your local introducers list with the
                                subscription's
    -r, --replace-introducers   Replace your local list of introducers with the
                                master list
    -n, --download-news         Retrieve news regarding the I2P grid.  These
                                will be stored in [node directory]/NEWS.
                                If you run this script as a cron job, the
                                news will also be emailed to you.
    --check-version             Check for a new version of this script on the
                                grid
    --download-update           Download a new version of this script from the
        [target directory]      grid (implies --check-version)
    -R, --repair-subscriptions  Maintain or repair the health of the subscription
                                service's URI
Options:
    -d [directory],             Specify the node directory (default: ~/.tahoe)
    --node-directory [directory]
    --list-uri [URI]            Override default location of introducers
                                list
    --no-proxy                  Disable proxy when downloading from non-tahoe URIs
    --news-uri [URI]            Override default location of news file
    --script-uri [URI]          Override default location of script updates
    -v, --verbose               Display more verbose output
    -V, --version               Display version information
    -h, --help                  Print this help text

Errors:
    If the script repeatedly fails to retrieve a file from the grid, the share
    may be damaged.  Try running --repair-subscriptions which will try to
    repair it.  If that doesn't help, you will most likely have to find a new
    URI to subscribe to.  Ask in #tahoe-lafs on Irc2P, check the DeepWiki
    and/or http://killyourtv.i2p.

EOF
}

TAHOE=$(which tahoe)
[ -z "$TAHOE" ] && echo "ERROR: \`tahoe\` executable not found." >&2 && exit 1

check_tahoe_node () {
	if [ -d $TAHOE_NODE_DIR ]; then
		if [ ! -e $TAHOE_NODE_DIR/node.url ]; then
			echo "ERROR: Cannot find $TAHOE_NODE_DIR/node.url. Not a valid tahoe node." >&2
			exit 1
		fi
		return 0
	else
		echo "ERROR: $TAHOE_NODE_DIR is not a directory." >&2
		exit 1
	fi
}

# Abort if any variables aren't initialized to try to prevent any surprises
set -o nounset  # same as set -u
set -e          # abort if there are any uncaught errors along the way

check_permissions () {
	if [ ! -w $TAHOE_NODE_DIR ]; then
		echo "ERROR: Need write permissions to "$TAHOE_NODE_DIR" to be able to update "$1"" >&2
		exit 1
	fi
	if [ -e "$2" ] && [ ! -w "$2" ]; then
		echo "ERROR: Need write permissions to \"$2\" to be able to update "$1"" >&2
		exit 1
	fi
}

pretty_print () {
	while read line ; do echo "$line" | sed 's/^/INFO:\ \ \ \ /'; done
}

download_list () {
	TMPLIST=$(mktemp $LOCKDIR/grid-update.XXXX)
	if [ $(echo $LISTURI |egrep '^http:') ]; then
		if ! eep_get "${LISTURI}/introducers" "$TMPLIST" "subscriptions"; then
			echo "ERROR: Could not retrieve the list from $LISTURI." >&2
			return 1
		fi
	else
		only_verbose echo "INFO: Attempting to download introducers list from the grid."
		if ! "$TAHOE" get "$LISTURI"/introducers "$TMPLIST" 2> /dev/null ; then
			echo "ERROR: Could not retrieve the list. Try again or check the share's integrity. See \`$0 --help.\`" >&2
			return 1
		fi
	fi
}

eep_get () {
	if [ -x "${HOME}/i2p/eepget" ] && [ ! $(echo ${PATH} | grep \/i2p) ]; then
		PATH="${PATH}:${HOME}/i2p" # try to ensure eepget is found
	fi

	if [ $OPT_NOPROXY ]; then
		unset http_proxy
	fi

	if [ $(which eepget) ]; then
		EEPTOOL="eepget"
		if [ $OPT_NOPROXY ]; then
			EEPFETCHCMD="${EEPTOOL} -n 2 ${1} -o ${2} -p :0"
		else
			EEPFETCHCMD="${EEPTOOL} -n 2 ${1} -o ${2} -p ${http_proxy}"
		fi
	elif [ $(which wget) ]; then
		EEPTOOL="wget"
		EEPFETCHCMD="${EEPTOOL} --tries=2 --quiet ${1} -O ${2}"
	elif [ $(which fetch) ]; then
		EEPTOOL="fetch"
		EEPFETCHCMD="${EEPTOOL} -q -o ${2} ${1}"
	elif [ $(which curl) ]; then
		EEPTOOL="curl"
		EEPFETCHCMD="${EEPTOOL} -s --retry 2 -L ${1} -o ${2}"
	else
		echo "ERROR: Couldn't find a tool capable of retrieving files from eepsites." >&2
		return 1
	fi

	if [ x${1} = "x" ]; then
		echo "INFO: Detected $EEPTOOL"
	else
		only_verbose echo "INFO: Attempting to download $3 using ${EEPTOOL}."
		$EEPFETCHCMD > /dev/null 2>&1
		if [ $? -gt 0 ]; then
			echo "ERROR: Failed to retrieve $3 from $1." >&2
			return 1
		fi
	fi
}

backup_list () {
	if [ -e "$INTRODUCER_LIST" ]; then
		LISTBAK="$INTRODUCER_LIST.bak"
		if [ ! -w "$LISTBAK" ] && ! touch "$LISTBAK" 2> /dev/null ; then
			echo "ERROR: Need write permissions to $LISTBAK to be able to update the file." >&2
			exit 1
		fi
		echo "# This is a backup of "$INTRODUCER_LIST". It was created by `basename $0` on $(date -u)." > "$LISTBAK"
		cat "$INTRODUCER_LIST" >> "$LISTBAK"
		return 0
	fi
}

merge_list () {
	INTRODUCER_LIST="$TAHOE_NODE_DIR/introducers"
	TMPLIST2=$(mktemp $LOCKDIR/grid-update.XXXX)
	if [ ! -e "$INTRODUCER_LIST" ]; then
		only_verbose echo "INFO: Unable to find "$INTRODUCER_LIST". Retrieving a new list."
		replace_list
		return 0
	else
		# Add new URIs in the subscribed list to the local list.
		# This resembles I2P's address book's system.
		check_permissions "the subscription list" "$INTRODUCER_LIST"
		download_list
		backup_list
		cat "$INTRODUCER_LIST.bak" "$TMPLIST" \
			| grep '^pb://' | sort -u > "$TMPLIST2"
		if diff -N "$TMPLIST2" "$INTRODUCER_LIST" > /dev/null 2>&1 ; then
			only_verbose echo "INFO: No new introducers found."
			return 0
		else
			cat "$INTRODUCER_LIST.bak" "$TMPLIST" \
				| grep '^pb://' | sort -u > "$INTRODUCER_LIST"  # merge
			only_verbose echo "INFO: Success: the list has been retrieved and merged. (Changes will take effect upon restart of the node.)"
		fi

		return 0
	fi
}

replace_list () {
	INTRODUCER_LIST="$TAHOE_NODE_DIR/introducers"
	# Make the local list identical to the subscribed one.
	check_permissions "the subscription list" "$INTRODUCER_LIST"
	download_list
	backup_list
	if diff -N "$LISTBAK" "$INTRODUCER_LIST" > /dev/null 2>&1; then
		mv -f "$TMPLIST" "$INTRODUCER_LIST" > /dev/null 2>&1   # install list
		only_verbose echo "INFO: Success: the list has been retrieved. (Changes will take effect upon restart of the node.)"
	elif [ ! -e "$INTRODUCER_LIST" ]; then # if we're here there was a back up but no introducer list
		mv -f "$TMPLIST" "$INTRODUCER_LIST" > /dev/null 2>&1   # install list
		only_verbose echo "INFO: Success: the list has been retrieved. (Changes will take effect upon restart of the node.)"
	else
		only_verbose echo "INFO: No updates available."
	fi
	return 0
}

checking_failed ()
{
	echo "ERROR: failed to check $1 share." >&2
	return 1
}

deep_check () {
	if [ $OPT_VERBOSE ]; then
		"$TAHOE" deep-check -v --repair --add-lease "$1" 2>/dev/null >&1 | pretty_print
	else
		"$TAHOE" deep-check --repair --add-lease "$1" >/dev/null 2>&1
	fi
}

repair_subscriptions () {
	check_tahoe_node

	only_verbose echo "INFO: Beginning to check subscription shares."
	only_verbose echo "INFO: Checking subscription share (1/3)."
	deep_check "$LISTURI" || checking_failed "subscriptions"

	only_verbose echo "INFO: Checking NEWS share (2/3)."
	deep_check "$NEWSURI" || checking_failed "news"

	only_verbose echo "INFO: Checking scripts share (3/3)."
	deep_check "$SCRIPTURI" || checking_failed "scripts"
}

print_news () {
	# if new NEWS...
	if ! diff -N "$TAHOENEWS" "$TMPNEWS" > /dev/null ; then
		# move old news aside
		if [ -e "$TAHOENEWS" ]; then
			cp -f "$TAHOENEWS" "$OLDNEWS"
		fi
		# put new news into place
		cp -f "$TMPNEWS" "$TAHOENEWS" > /dev/null
		# print
		diff --ignore-all-space --ignore-blank-lines --new-file \
		        "$OLDNEWS" "$TAHOENEWS" | grep -e "^>\ " | sed 's/^>\ //'
		return 0
	else
		only_verbose echo "INFO: There are no news."
		return 0
	fi
}

download_news () {
	TAHOENEWS="$TAHOE_NODE_DIR/NEWS"
	check_permissions "news" "$TAHOENEWS"
	TMPNEWS=$(mktemp $LOCKDIR/grid-update.XXXX)
	OLDNEWS=$(mktemp $LOCKDIR/grid-update.XXXX)
	if [ $(echo $NEWSURI |egrep '^http:') ]; then
		if eep_get "${NEWSURI}/NEWS" "$TMPNEWS" "news"; then
			print_news
			return 0
		else
			echo "ERROR: Could not retrieve the news from $NEWSURI." >&2
			return 1
		fi
	else
		only_verbose echo "INFO: Attempting to download the NEWS file from the grid."
		if "$TAHOE" get "$NEWSURI/NEWS" "$TMPNEWS" 2> /dev/null ; then
			print_news
			return 0
		else
			echo "ERROR: Couldn't fetch the NEWS file." >&2
			exit 1
		fi
	fi
}

check_uri () {
	# Tahoe URIs will start with URI:
	#Yes, this is very rudimentary checking,
	# but it's better than nothing...isn't it?

	if [ ! $(echo "$1" | grep '^URI:') ] && [ ! $(echo "$1" | egrep '^http:') ] ; then
		echo "ERROR: "$1" is not a valid ${2}-uri." >&2
		return 1
	fi
}

check_version () {
	if [ $(echo $SCRIPTURI |egrep '^http:') ]; then
		echo "ERROR: Script updates are not currently supported from eepSites." >&2
		return 1
	fi
	LC_ALL=C # make sure sort order is what we expect
	only_verbose echo "INFO: Attempting to check for new version."
	# sort -V not on FreeBSD. These sort parameters were taken from http://stackoverflow.com/a/4046149
	LATEST_VERSION_FILENAME=$(tahoe ls $SCRIPTURI | grep 'grid-updates-v[[:digit:]]\.[[:digit:]].*\.tgz' | sort -r -t- -k2,2 -n | head -n 1)
	if [ "$LATEST_VERSION_FILENAME" ]; then
		LATEST_AVAILABLE_VERSION=$(echo $LATEST_VERSION_FILENAME | sed 's/^grid-updates-v\(.*\)\.tgz$/\1/')
		NEWEST_VERSION=$(/bin/echo -e "$VERSION\n$LATEST_AVAILABLE_VERSION" | sort -r -t- -k2,2 -n | head -n 1)
		if [ "$VERSION" != "$NEWEST_VERSION" ]; then
			# Only print if not called via --download-update
			[ ! $OPT_DOWNLOAD_UPDATE ] && echo "New version available: $LATEST_AVAILABLE_VERSION."
			return 0
		else
			# Only print if not called via --download-update
			[ ! $OPT_DOWNLOAD_UPDATE ] && echo "No new version available."
			return 1
		fi
	else
		echo "Error: Nothing found. This doesn't seem to be a download location for grid-updates." >&2
	fi
}

download_update () {
	if [ ! -d $UPDATE_DOWNLOAD_DIR ]; then
		echo "ERROR: $UPDATE_DOWNLOAD_DIR is not a directory." >&2
		exit 1
	fi

	if [ ! -w $UPDATE_DOWNLOAD_DIR ]; then
		echo "ERROR: Cannot write to download directory $UPDATE_DOWNLOAD_DIR." >&2
		exit 1
	fi

	if check_version; then
		only_verbose echo "INFO: New version available: $LATEST_AVAILABLE_VERSION."
		only_verbose echo "INFO: Attempting to download new version."
		if tahoe get $SCRIPTURI/$LATEST_VERSION_FILENAME "$UPDATE_DOWNLOAD_DIR/$LATEST_VERSION_FILENAME" 2> /dev/null ; then
			echo "Update found (version $LATEST_AVAILABLE_VERSION) and downloaded to $UPDATE_DOWNLOAD_DIR/$LATEST_VERSION_FILENAME."
		fi
	else
		only_verbose echo "INFO: No new version available."
	fi
}

# Useful constants
: ${TAHOE_NODE_DIR:="$HOME/.tahoe"}
: ${http_proxy:="127.0.0.1:4444"}
export http_proxy

# some of those variables will not be initialized--and that's OK.
# We'll do our own checking from this point forward.
set +u

while [ $# -gt 0 ] ; do
	case $1 in
		--node-directory|-d)
			if [ -z "$2" ]; then
				echo "ERROR: Tahoe node directory not specified." >&2
				print_help
				exit 1
			fi
			TAHOE_NODE_DIR=$2
			shift 2
			check_tahoe_node
		;;
		--list-uri)
			if [ -z "$2" ]; then
				echo "ERROR: list-uri not specified." >&2
				print_help
				exit 1
			fi
			LISTURI=$2
			shift 2
			check_uri "$LISTURI" "list"
		;;
		--news-uri)
			if [ -z "$2" ]; then
				echo "ERROR: news-uri not specified." >&2
				print_help
				exit 1
			fi
			NEWSURI=$2
			shift 2
			check_uri "$NEWSURI" "news"
		;;
		--script-uri)
			if [ -z "$2" ]; then
				echo "ERROR: script-uri not specified." >&2
				print_help
				exit 1
			fi
			SCRIPTURI=$2
			shift 2
			check_uri "$SCRIPTURI" "script"
		;;
		--merge-introducers|-m)
			OPT_MERGE_LIST=1
			shift
		;;
		--replace-introducers|-r)
			OPT_REPLACE_LIST=1
			shift
		;;
		--repair-subscriptions|-R)
			OPT_REPAIR_SUBSCRIPTIONS=1
			shift
		;;
		--download-news|-n)
			OPT_DOWNLOAD_NEWS=1
			shift
		;;
		--version|-V)
			echo "$(basename $0) version: $VERSION"
			exit 0
		;;
		--check-version)
			OPT_CHECK_VERSION=1
			shift
		;;
		--no-proxy)
			OPT_NOPROXY=1
			shift
			;;
		--download-update)
			if [ -z "$2" ]; then
				only_verbose echo "INFO: No download directory specified. Using $PWD/."
				UPDATE_DOWNLOAD_DIR="$PWD"
				OPT_DOWNLOAD_UPDATE=1
				shift
			else
				UPDATE_DOWNLOAD_DIR="$2"
				OPT_DOWNLOAD_UPDATE=1
				shift 2
			fi
		;;
		--verbose|-v)
			OPT_VERBOSE=1
			shift
		;;
		--help|-h)
			print_help
			exit
		;;
		*)
			echo "ERROR: Unknown command." >&2
			print_help
			exit 1
		;;
	esac
done

if [ ! $OPT_MERGE_LIST ] && [ ! $OPT_REPLACE_LIST ] && \
[ ! $OPT_REPAIR_SUBSCRIPTIONS ] && [ ! $OPT_DOWNLOAD_NEWS ] && \
[ ! $OPT_CHECK_VERSION ] && [ ! $OPT_DOWNLOAD_UPDATE ]; then
	echo "ERROR: You need to specify an action." >&2
	print_help
	exit 1
fi
[ $OPT_REPAIR_SUBSCRIPTIONS ] && repair_subscriptions
if [ $OPT_MERGE_LIST ] && [ ! $OPT_REPLACE_LIST ]; then
	merge_list
elif [ ! $OPT_MERGE_LIST ] && [ $OPT_REPLACE_LIST ]; then
	replace_list
elif [ $OPT_MERGE_LIST ] && [ $OPT_REPLACE_LIST ]; then
	echo "ERROR: --merge-introducers and --replace-introducers are mutually exclusive." >&2
	print_help
	exit 1
fi
[ $OPT_DOWNLOAD_NEWS ] && download_news
if [ $OPT_CHECK_VERSION ] && [ $OPT_DOWNLOAD_UPDATE ]; then
	download_update
elif [ $OPT_DOWNLOAD_UPDATE ]; then
	download_update
elif [ $OPT_CHECK_VERSION ]; then
	check_version
fi

exit 0
