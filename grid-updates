#!/bin/sh

# grid-updates -- a helper script for a Tahoe-LAFS nodes
#
#
# Authors:
#     darrob <darrob@mail.i2p>
#     KillYourTV <kytv@mail.i2p>
#
# License: public domain
#
# Requirements:
#     Bourne-compatible shell, Tahoe-LAFS

# For more information see the README.md and INSTALL.md files.

# This script's version:
VERSION='0.7.2'

################################## DEFAULTS ###################################
# Default location of the Tahoe-LAFS node:
DEFAULT_TAHOE_NODE_DIR="$HOME/.tahoe"
# Default location (directory) of the subscription list:
DEFAULT_LISTURI='URI:DIR2-RO:t4fs6cqxaoav3r767ce5t6j3h4:gvjawwbjljythw4bjhgbco4mqn43ywfshdi2iqdxyhqzovrqazua'
# Default location (directory) of the NEWS file:
DEFAULT_NEWSURI='URI:DIR2-RO:hx6754mru4kjn5xhda2fdxhaiu:hbk4u6s7cqfiurqgqcnkv2ckwwxk4lybuq3brsaj2bq5hzajd65q'
# Default location (directory) of script releases:
DEFAULT_SCRIPTURI='URI:DIR2-RO:mjozenx3522pxtqyruekcx7mh4:eaqgy2gfsb73wb4f4z2csbjyoh7imwxn22g4qi332dgcvfyzg73a'
DEFAULT_HTTP_PROXY='127.0.0.1:4444'
# Web UI checksums of Tahoe-LAFS version 1.8.3:
ORIGINAL_WEBUI_WELCOME_CHECKSUM="7c57343303b08d785a9301795b27a5552439c68987aab851576a311594b70367"
ORIGINAL_WEBUI_CSS_CHECKSUM="76c58b765a9c1ee589783a56bc238af70bd7ca101b1db7189454970941223996"
###############################################################################

[ -z "$XDG_CONFIG_HOME" ] && XDG_CONFIG_HOME="$HOME/.config"
[ -z "$XDG_CONFIG_DIRS" ] && XDG_CONFIG_DIRS="/etc/xdg"

### Various helper functions used throughout ###

only_verbose () {
	if [ $OPT_VERBOSE ]; then $@ ; fi
}

only_debug () {
	if [ $OPT_DEBUG ]; then $@ ; fi
}

pretty_print () {
	while read line ; do echo "$line" | sed 's/^/INFO:\ \ \ \ /'; done
}

checking_failed ()
{
	echo "ERROR: failed to check $1 share." >&2
	return 1
}

run () {
	# http://unix.derkeiler.com/Newsgroups/comp.unix.shell/2005-06/1079.html
	j=1
	while eval "\${pipestatus_$j+:} false"; do
		unset pipestatus_$j
		j=$(($j+1))
	done
	j=1 com= k=1 l=
	for a; do
		if [ "x$a" = 'x|' ]; then
			com="$com { $l "'3>&-
				echo "pipestatus_'$j'=$?" >&3
					} 4>&- |'
			j=$(($j+1)) l=
		else
			l="$l \"\$$k\""
		fi
		k=$(($k+1))
	done
	com="$com $l"' 3>&- >&4 4>&-
			echo "pipestatus_'$j'=$?"'
	exec 4>&1
	eval "$(exec 3>&1; eval "$com")"
	exec 4>&-
	j=1
	while eval "\${pipestatus_$j+:} false"; do
		eval "[ \$pipestatus_$j -eq 0 ]" || return 1
		j=$(($j+1))
	done
	return 0
}

print_help () {
cat << EOF
Usage: $0 [OPTIONS] [ACTIONS]

Actions:
  -m, --merge-introducers       Merge your local introducers list with the
                                subscription's.
  -r, --replace-introducers     Replace your local introducers list with the
                                subscription's.
  -n, --download-news           Retrieve grid-updates news feed.
  -R, --repair-subscriptions    Maintain or repair the health of the
                                subscription service's URIs.
  -C [FILE],                    Create a config file with the default settings.
    --create-config [FILE]
  --patch-tahoe                 Patch the Tahoe web console to display the
                                grid-updates news feed in an Iframe.
  --undo-patch-tahoe            Restore the original Tahoe web console.
  --make-news [Markdown FILE]   Create a grid-updates-compatible NEWS.tgz file.
  --check-version               Check for a new version of grid-updates.
  --download-update [DIRECTORY] Download a new version of grid-updates.

Options:
  -c FILE, --config FILE        Specify a grid-updates config file.
  -d DIRECTORY,                 Specify the node directory.
    --node-directory DIRECTORY
  --list-uri URI                Override default location of introducers list.
  --news-uri URI                Override default location of news file.
  --script-uri URI              Override default location of script updates.
  --download-tool NAME          Manually specify the tool for HTTP downloads.
  --no-proxy                    Disable proxy for HTTP URI downloads.
  -v, --verbose                 Display more verbose output.
  -V, --version                 Display version information.
  -h, --help                    Print this help text.

Errors:
  If the script repeatedly fails to retrieve a file from the grid, the share may
  be damaged.  See the ERRORS section in the man page (\`man grid-updates\`) for
  solutions.

EOF
}

### config files ###

parse_config_item () {
	OPTION=$1
	if grep -q "^$OPTION" "$CONFIG_FILE" ; then
		# XXX: are these regex's too broad?
		PARSED_OPTION=$(grep --max-count=1 "^$OPTION" $CONFIG_FILE |
			sed -e 's/^\w\+[\ \t]*=[\ \t]*\(.*\)$/\1/')
		if [ -z "$PARSED_OPTION" ]; then
			echo "WARNING: Illegal value for '$OPTION' in $CONFIG_FILE. Ignoring it."
		else
			eval "PARSED_$OPTION=$PARSED_OPTION"
			export "PARSED_$OPTION"
		fi
	fi
	unset PARSED_OPTION
}

parse_config_file () {
	# Parse option if available
	parse_config_item "LISTURI"
	parse_config_item "NEWSURI"
	parse_config_item "SCRIPTURI"
	parse_config_item "TAHOE_NODE_DIR"
	parse_config_item "HTTP_PROXY"
	parse_config_item "USE_PROXY"
	parse_config_item "DOWNLOAD_TOOL"
	# Set parsed value if option is still unset
	if [ -z $LISTURI ] && [ -n $PARSED_LISTURI ]; then
		LISTURI="$PARSED_LISTURI"
	fi
	if [ -z $NEWSURI ] && [ -n $PARSED_NEWSURI ]; then
		NEWSURI="$PARSED_NEWSURI"
	fi
	if [ -z $SCRIPTURI ] && [ -n $PARSED_SCRIPTURI ]; then
		SCRIPTURI="$PARSED_SCRIPTURI"
	fi
	if [ -z $TAHOE_NODE_DIR ] && [ -n $PARSED_TAHOE_NODE_DIR ]; then
		TAHOE_NODE_DIR="$PARSED_TAHOE_NODE_DIR"
	fi
	if [ -z $http_proxy ] && [ -n $PARSED_HTTP_PROXY ]; then
		http_proxy="$PARSED_HTTP_PROXY"
	fi
	case $PARSED_USE_PROXY in
		N*|n*|F*|f*)
		OPT_NOPROXY=1
		;;
	Y*|y*|T*|t*)
		OPT_NOPROXY=0
		;;
	*)
		;; # pass
	esac
	if [ -z $DOWNLOAD_TOOL ] && [ -n $PARSED_DOWNLOAD_TOOL ]; then
		DOWNLOAD_TOOL="$PARSED_DOWNLOAD_TOOL"
	fi
	return 0
}

create_config_file ()
{
	if [ "x$CONFIG_FILE" = "x" ]; then
		mkdir -p "$XDG_CONFIG_HOME/grid-updates" || (echo "ERROR: Failed to create directory $XDG_CONFIG_HOME/grid-updates." >&2; exit 1)
		CONFIG_FILE="$XDG_CONFIG_HOME/grid-updates/config"
	fi
	# TODO We should update the config file when options change or are added instead of failing outright.
	# If the config file exists we just exit.
	if [ ! -e "$CONFIG_FILE" ]; then
		http_download > /dev/null 2>&1
		cat << EOF > $CONFIG_FILE || (echo "ERROR: Failed to create the file $CONFIG_FILE." >&2; exit 1)
# grid-updates $VERSION config

# If the tahoe node is not in a standard location, set the correct path here
#TAHOE_NODE_DIR=$DEFAULT_TAHOE_NODE_DIR

#LISTURI=$DEFAULT_LISTURI
#NEWSURI=$DEFAULT_NEWSURI
#SCRIPTURI=$DEFAULT_SCRIPTURI

# These are only used when fetching from non-tahoe URIs
#DOWNLOAD_TOOL="$DOWNLOAD_TOOL"
#HTTP_PROXY=$DEFAULT_HTTP_PROXY
#USE_PROXY=yes
EOF
		echo "Default config file created at $CONFIG_FILE."
		exit 0
	else
		echo "ERROR: $CONFIG_FILE already exists." >&2
		exit 1
	fi
}

read_config_files () {
	only_debug echo "DEBUG: Parsing configuration files."
	# Parse specified config file (--config)
	if [ $OPT_CONFIG_FILE ] ; then
		CONFIG_FILE="$SPECIFIED_CONFIG_FILE"
		if [ -f "$CONFIG_FILE" ]; then
			only_debug echo "DEBUG: Config files specified and found at $CONFIG_FILE."
			parse_config_file
		else
			echo "ERROR: Config file $CONFIG_FILE not found."
			exit 1
		fi
	fi
	# Parse files in standard locations if available
	if [ -f "$XDG_CONFIG_HOME/grid-updates/config" ]; then
		CONFIG_FILE="$XDG_CONFIG_HOME/grid-updates/config"
		only_debug echo "DEBUG: Parsing config file $CONFIG_FILE."
		parse_config_file
	fi
	if [ -f "$XDG_CONFIG_DIRS/grid-updates/config" ]; then
		CONFIG_FILE="$XDG_CONFIG_DIRS/grid-updates/config"
		only_debug echo "DEBUG: Parsing config file $CONFIG_FILE."
		parse_config_file
	fi
	# Apply default values where necessary
	[ -z $LISTURI ] && LISTURI="$DEFAULT_LISTURI"
	[ -z $NEWSURI ] && NEWSURI="$DEFAULT_NEWSURI"
	[ -z $SCRIPTURI ] && SCRIPTURI="$DEFAULT_SCRIPTURI"
	[ -z $TAHOE_NODE_DIR ] && TAHOE_NODE_DIR="$DEFAULT_TAHOE_NODE_DIR"
	[ -z $http_proxy ] && http_proxy="$DEFAULT_HTTP_PROXY"
	return 0
}

### checks ###

check_tahoe_node () {
	only_debug echo "DEBUG: Checking if Tahoe node directory is valid."
	if [ -d "$TAHOE_NODE_DIR" ]; then
		if [ ! -e $TAHOE_NODE_DIR/node.url ]; then
			echo "ERROR: Cannot find $TAHOE_NODE_DIR/node.url. Not a valid tahoe node." >&2
			exit 1
		fi
		return 0
	elif [ $OPT_PATCH_TAHOE ] && [ $(id -ur) -eq 0 ] ; then
		# we don't care about the node directory if running as root and patching
		return 0
	else
		echo "ERROR: $TAHOE_NODE_DIR is not a directory." >&2
		exit 1
	fi
}

check_permissions () {
	only_debug echo "DEBUG: Checking file permissions in Tahoe node directory."
	if [ ! -w "$TAHOE_NODE_DIR" ]; then
		echo "ERROR: Need write permissions to "$TAHOE_NODE_DIR" to be able to update "$1"" >&2
		exit 1
	fi
	if [ -e "$2" ] && [ ! -w "$2" ]; then
		echo "ERROR: Need write permissions to \"$2\" to be able to update "$1"" >&2
		exit 1
	fi
}

check_uri () {
	# Tahoe URIs will start with URI:
	#Yes, this is very rudimentary checking,
	# but it's better than nothing...isn't it?
	if [ ! $(echo "$1" | grep '^URI:') ] && [ ! $(echo "$1" | egrep '^http:') ] ; then
		echo "ERROR: "$1" is not a valid ${2}-uri." >&2
		return 1
	fi
}

choose_http_download_tool () {
	# Look for I2P
	if [ -z $I2P ]; then
		if [ -e /usr/share/i2p/lib/i2p.jar ]; then
			I2P="/usr/share/i2p"
			only_debug echo "DEBUG: Found I2P in $I2P."
		elif [ -e "$HOME/i2p/lib/i2p.jar" ]; then
			I2P="$HOME/i2p"
			only_debug echo "DEBUG: Found I2P in $I2P."
		else
			I2P="nfc"
			only_debug echo "DEBUG: Couldn't find an I2P installation."
		fi
	fi
	only_debug echo "DEBUG: Determining download tool to use."
	if [ -n "$DOWNLOAD_TOOL" ]; then
		# Check user-specified download tool is valid
		case "$DOWNLOAD_TOOL" in
			"eepget"|"wget"|"fetch"|"curl")
				# pass
				only_debug echo "DEBUG: Using user-specified download tool: $DOWNLOAD_TOOL."
				;;
			*)
				echo "ERROR: Unknown download tool."
				return 1
				;;
		esac
	else
		# Find available download tools
		if [ -f "$I2P/lib/i2p.jar" ]; then DOWNLOAD_TOOL="eepget"
		elif [ $(which wget) ]; then DOWNLOAD_TOOL="wget"
		elif [ $(which fetch) ]; then DOWNLOAD_TOOL="fetch"
		elif [ $(which curl) ]; then DOWNLOAD_TOOL="curl"
		else
			echo "ERROR: Couldn't find a tool capable of retrieving files from HTTP resources." >&2
			return 1
		fi
		only_debug echo "DEBUG: Automatically chose download tool $DOWNLOAD_TOOL."
	fi
	# Configure download tool command
	if [ "$DOWNLOAD_TOOL" = "eepget" ]; then
		HTTP_DOWNLOAD_CMD="java -jar $I2P/lib/i2p.jar net.util.EepGet -o ${DL_TARGET_LOCATION} ${DL_REMOTE_LOCATION}"
	elif [ "$DOWNLOAD_TOOL" = "wget" ]; then
		HTTP_DOWNLOAD_CMD="${DOWNLOAD_TOOL} --tries=2 --quiet ${DL_REMOTE_LOCATION} -O ${DL_TARGET_LOCATION}"
	elif [ "$DOWNLOAD_TOOL" = "fetch" ]; then
		HTTP_DOWNLOAD_CMD="${DOWNLOAD_TOOL} -q -o ${DL_TARGET_LOCATION} ${DL_REMOTE_LOCATION}"
	elif [ "$DOWNLOAD_TOOL" = "curl" ]; then
		HTTP_DOWNLOAD_CMD="${DOWNLOAD_TOOL} -s --retry 2 -L ${DL_REMOTE_LOCATION} -o ${DL_TARGET_LOCATION}"
	fi
}

http_download () {
	DL_REMOTE_LOCATION="$1"
	DL_TARGET_LOCATION="$2"
	DL_REMOTE_NAME="$3"
	choose_http_download_tool
	if [ $OPT_NOPROXY ]; then
		only_debug echo "DEBUG: Disabling http_proxy as requested."
		unset http_proxy
	fi

	if [ x${DL_REMOTE_LOCATION} = "x" ]; then
		# We'll only arrive here if http_download is called
		# without any parameters. For potential future
		# use.
		echo "Detected $DOWNLOAD_TOOL"
		if [ ! -z $I2PVERSION ]; then
			echo "I2PVERSION: $I2PVERSION"
		fi
	else
		if [ $OPT_NOPROXY ]; then
			only_verbose echo "INFO: Attempting to download $DL_REMOTE_NAME using ${DOWNLOAD_TOOL} from ${DL_REMOTE_LOCATION} (no proxy)."
		else
			only_verbose echo "INFO: Attempting to download $DL_REMOTE_NAME using ${DOWNLOAD_TOOL} from ${DL_REMOTE_LOCATION} (proxy ${http_proxy})."
		fi
		only_debug echo "DEBUG: Running $HTTP_DOWNLOAD_CMD."
		$HTTP_DOWNLOAD_CMD > /dev/null 2>&1
		if [ $? -gt 0 ]; then
			echo "ERROR: Failed to retrieve $DL_REMOTE_NAME from $1." >&2
			return 1
		fi
	fi
}

### introducers ###

filter_furls () {
	grep --no-filename -e '^pb://[a-zA-Z0-9-]\+@.\+/.\+$' $@
}

download_list () {
	DLLIST=$(mktemp $LOCKDIR/grid-update.XXXX)
	TMPLIST=$(mktemp $LOCKDIR/grid-update.XXXX)
	if [ $(echo $LISTURI |egrep '^http:') ]; then
		only_verbose echo "INFO: Downloading list from HTTP resource."
		if ! http_download "${LISTURI}/introducers" "$DLLIST" "subscriptions"; then
			echo "ERROR: Could not retrieve the list from $LISTURI." >&2
			return 1
		fi
		filter_furls $DLLIST | sort -u > "$TMPLIST"
	else
		only_verbose echo "INFO: Attempting to download introducers list from the grid ($LISTURI)."
		if ! "$TAHOE" get "$LISTURI"/introducers "$DLLIST" 2> /dev/null ; then
			echo "ERROR: Could not retrieve the list. Try again or check the share's integrity. See \`$0 --help.\`" >&2
			return 1
		fi
		filter_furls $DLLIST | sort -u > "$TMPLIST"
	fi
}

backup_list () {
	only_debug echo "DEBUG: Making a backup copy of the introducers file."
	if [ -e "$INTRODUCER_LIST" ]; then
		LISTBAK="$INTRODUCER_LIST.bak"
		if [ ! -w "$LISTBAK" ] && ! touch "$LISTBAK" 2> /dev/null ; then
			echo "ERROR: Need write permissions to $LISTBAK to be able to update the file." >&2
			exit 1
		fi
		echo "# This is a backup of "$INTRODUCER_LIST". It was created by `basename $0` on $(date -u)." > "$LISTBAK"
		cat "$INTRODUCER_LIST" >> "$LISTBAK"
		return 0
	fi
}

merge_list () {
	only_debug echo "DEBUG: Attempting to merge the introducers lists."
	INTRODUCER_LIST="$TAHOE_NODE_DIR/introducers"
	TMPLIST2=$(mktemp $LOCKDIR/grid-update.XXXX)
	if [ ! -e "$INTRODUCER_LIST" ]; then
		only_verbose echo "INFO: Unable to find "$INTRODUCER_LIST". Retrieving a new list."
		replace_list
		return 0
	else
		# Add new URIs in the subscribed list to the local list.
		# This resembles I2P's address book's system.
		check_permissions "the subscription list" "$INTRODUCER_LIST"
		download_list
		backup_list
		filter_furls "$INTRODUCER_LIST.bak" "$TMPLIST" | sort -u > "$TMPLIST2"
		if diff -N "$TMPLIST2" "$INTRODUCER_LIST" > /dev/null 2>&1 ; then
			only_verbose echo "INFO: No new introducers found."
			return 0
		else
		filter_furls "$INTRODUCER_LIST.bak" "$TMPLIST" | sort -u > "$INTRODUCER_LIST" # merge
			only_verbose echo "INFO: Success: the list has been retrieved and merged. (Changes will take effect upon restart of the node.)"
		fi
		return 0
	fi
}

replace_list () {
	only_debug echo "DEBUG: Attempting to replace the local introducers list."
	INTRODUCER_LIST="$TAHOE_NODE_DIR/introducers"
	# Make the local list identical to the subscribed one.
	check_permissions "the subscription list" "$INTRODUCER_LIST"
	backup_list
	download_list
	FILTERED_LISTBAK=$(mktemp $LOCKDIR/grid-update.XXXX)
	filter_furls "$LISTBAK" |sort -u > "$FILTERED_LISTBAK"
	if ! diff -N "$FILTERED_LISTBAK" "$TMPLIST" > /dev/null 2>&1; then
		mv -f "$TMPLIST" "$INTRODUCER_LIST" > /dev/null 2>&1   # install list
		only_verbose echo "INFO: Success: the list has been retrieved. (Changes will take effect upon restart of the node.)"
	elif [ ! -e "$INTRODUCER_LIST" ]; then # if we're here there was a back up but no introducer list
		mv -f "$TMPLIST" "$INTRODUCER_LIST" > /dev/null 2>&1   # install list
		only_verbose echo "INFO: Success: the list has been retrieved. (Changes will take effect upon restart of the node.)"
	else
		only_verbose echo "INFO: No updates to the introducers list available."
	fi
	return 0
}

### news ###

check_pubhtml_permissions () {
	only_debug echo "DEBUG: Checking access permissions of Tahoe's web.static directory."
	if [ ! $WEB_STATIC ]; then
		echo "Error: could not find 'web.static' option in $TAHOE_CFG." >&2
		return 1
	fi
	if [ ! -r $TAHOE_CFG ]; then
		echo "Error: cannot read $TAHOE_CFG." >&2
		return 1
	fi
	if [ ! -w "$PUB_HTML_DIR" ]; then
		if ! mkdir $PUB_HTML_DIR ; then
			echo "Error: cannot write to or create $PUB_HTML_DIR." >&2
			return 1
		fi
	fi
}

check_newshtml_exists () {
	only_debug echo "DEBUG: Check if NEWS.html file exists."
	if [ $OPT_PATCH_TAHOE ] && [ $(id -ur) -eq 0 ] ; then
		# we don't care about tahoe.cfg if running as root and patching
		return 0
	else
		TAHOE_CFG="$TAHOE_NODE_DIR/tahoe.cfg"
		WEB_STATIC="$(sed -e '/^web\.static/!d' -e 's/^web\.static\ *=\ *//' $TAHOE_CFG)"
		PUB_HTML_DIR="$TAHOE_NODE_DIR/$WEB_STATIC"
		if [ ! -e $PUB_HTML_DIR/NEWS.html ]; then
			check_pubhtml_permissions || return 1
			make_newshtml_placeholder > $PUB_HTML_DIR/NEWS.html
		fi
	fi
}

make_newshtml_placeholder () {
only_debug echo "DEBUG: Creating a NEWS.html placeholder."
cat << EOF
<html><head></head><body><small>
	<p>
		This space is for news items downloaded by
		<code><strong>grid-updates</strong></code>.  Please run <code>grid-updates
		--download-news</code> to download the latest news file from the
		Tahoe-LAFS grid.
	</p>
	<p>
		If you haven't installed grid-updates already, please consider doing
		so.  You can obtain it from the following locations:
		<ul>
			<li><a href="http://darrob.i2p/grid-updates/">http://darrob.i2p/grid-updates/</a></li>
			<li><a href="http://git.repo.i2p/w/grid-updates.git">http://git.repo.i2p/w/grid-updates.git</a></li>
			<li>
				<a href='http://127.0.0.1:3456/uri/URI%3ADIR2-RO%3Amjozenx3522pxtqyruekcx7mh4%3Aeaqgy2gfsb73wb4f4z2csbjyoh7imwxn22g4qi332dgcvfyzg73a/'>URI:DIR2-RO:mjozenx3522pxtqyruekcx7mh4:eaqgy2gfsb73wb4f4z2csbjyoh7imwxn22g4qi332dgcvfyzg73a</a>
			</li>
		</ul>
	</p>
	<p>
		If you want to get rid of this area, run <code>grid-updates
		--undo-tahoe-patch</code>.
	</p>
</small></body></html>
EOF
}

print_news () {
	# if new NEWS...
	if ! diff -N "$TAHOE_NEWS" "$TMP_NEWS_PLAIN" > /dev/null ; then
		only_debug echo "DEBUG: Printing new NEWS file."
		# move old news aside
		if [ -e "$TAHOE_NEWS" ]; then
			cp -f "$TAHOE_NEWS" "$OLD_NEWS"
		fi
		# put new news into place
		cp -f "$TMP_NEWS_PLAIN" "$TAHOE_NEWS" > /dev/null
		# print
		cat "$TAHOE_NEWS"
		# Copy HTML version into place
		cp -f $TMP_NEWS_DIR/NEWS.html $PUB_HTML_DIR/NEWS.html
		cp -f $TMP_NEWS_DIR/NEWS.atom $PUB_HTML_DIR/NEWS.atom
		return 0
	else
		only_verbose echo "INFO: There are no news."
		# Copy HTML version into place
		cp -f $TMP_NEWS_DIR/NEWS.html $PUB_HTML_DIR/NEWS.html
		cp -f $TMP_NEWS_DIR/NEWS.atom $PUB_HTML_DIR/NEWS.atom
		return 0
	fi
}

download_news () {
	only_debug echo "DEBUG: Attempting to download NEWS file."
	TAHOE_NEWS="$TAHOE_NODE_DIR/NEWS"
	check_permissions "news" "$TAHOE_NEWS"
	TMP_NEWS_TGZ=$(mktemp $LOCKDIR/grid-update.XXXX)
	TMP_NEWS_DIR=$(mktemp -d $LOCKDIR/grid-update.XXXX)
	TMP_NEWS_PLAIN="$TMP_NEWS_DIR/NEWS"
	OLD_NEWS=$(mktemp $LOCKDIR/grid-update.XXXX)
	check_pubhtml_permissions
	if [ $(echo $NEWSURI |egrep '^http:') ]; then
		if http_download "${NEWSURI}/NEWS.tgz" "$TMP_NEWS_DIR/NEWS.tgz" "news"; then
			tar xzf "$TMP_NEWS_DIR/NEWS.tgz" --directory "$TMP_NEWS_DIR"
			print_news
			return 0
		else
			echo "ERROR: Could not retrieve the news from $NEWSURI." >&2
			return 1
		fi
	else
		only_verbose echo "INFO: Attempting to download the NEWS.tgz file from the grid ($NEWSURI)."
		if "$TAHOE" get "$NEWSURI/NEWS.tgz" "$TMP_NEWS_DIR/NEWS.tgz" 2> /dev/null ; then
			tar xzf "$TMP_NEWS_DIR/NEWS.tgz" --directory "$TMP_NEWS_DIR"
			print_news
			return 0
		else
			echo "ERROR: Couldn't fetch the NEWS file." >&2
			exit 1
		fi
	fi
}

### Tahoe deep-check ###

deep_check () {
	if [ $OPT_VERBOSE ]; then
		run "$TAHOE" deep-check -v --repair --add-lease "$1" 2>/dev/null >&1 \| pretty_print
		return $pipestatus_1 # return exit value of `tahoe deep-check`
	else
		"$TAHOE" deep-check --repair --add-lease "$1" >/dev/null 2>&1
	fi
}

repair_subscriptions () {
	check_tahoe_node
	only_verbose echo "INFO: Beginning to check subscription shares."
	only_verbose echo "INFO: 1/3: Checking introducers list share ($LISTURI)."
	deep_check "$LISTURI" || checking_failed "subscriptions"
	only_verbose echo "INFO: 2/3 Checking NEWS share ($NEWSURI)."
	deep_check "$NEWSURI" || checking_failed "news"
	only_verbose echo "INFO: 3/3: Checking scripts share ($SCRIPTURI)."
	deep_check "$SCRIPTURI" || checking_failed "scripts"
}

### version / update check ###

check_version () {
	if [ $(echo $SCRIPTURI |egrep '^http:') ]; then
		echo "ERROR: Script updates are not currently supported from eepSites." >&2
		return 1
	fi
	LC_ALL=C # make sure sort order is what we expect
	only_verbose echo "INFO: Attempting to check for new version (in $SCRIPTURI)."
	# sort -V not on FreeBSD. These sort parameters were taken from http://stackoverflow.com/a/4046149
	LATEST_VERSION_FILENAME=$("$TAHOE" ls $SCRIPTURI | grep 'grid-updates-v[[:digit:]]\.[[:digit:]].*\.tgz' | sort -r -V | head -n 1)
	if [ "$LATEST_VERSION_FILENAME" ]; then
		LATEST_AVAILABLE_VERSION=$(echo $LATEST_VERSION_FILENAME | sed 's/^grid-updates-v\(.*\)\.tgz$/\1/')
		only_debug echo "DEBUG: Latest availble version: $LATEST_AVAILABLE_VERSION."
		if [ $(uname -s |tr "[A-Z]" "[a-z]") != "linux" ]; then
			NEWEST_VERSION=$(echo -e "$VERSION\n$LATEST_AVAILABLE_VERSION" | sort -r -V | head -n 1)
		else
			NEWEST_VERSION=$(/bin/echo -e "$VERSION\n$LATEST_AVAILABLE_VERSION" | sort -r -V | head -n 1)
		fi
		only_debug echo "DEBUG: Newest version: $LATEST_AVAILABLE_VERSION."
		if [ "$VERSION" != "$NEWEST_VERSION" ]; then
			# Only print if not called via --download-update
			[ ! $OPT_DOWNLOAD_UPDATE ] && echo "New version available: $LATEST_AVAILABLE_VERSION."
			export NEW_GU_VERSION_AVAILABLE=1
		else
			# Only print if not called via --download-update
			[ ! $OPT_DOWNLOAD_UPDATE ] && echo "No new version available."
			export NEW_GU_VERSION_AVAILABLE=0
		fi
	else
		echo "Error: Nothing found. This doesn't seem to be a download location for grid-updates." >&2
	fi
	# Also check Tahoe web console patch versions
	if [ "$PATCHES_FOUND" = "y" ]; then
		find_webui_files || return 1
		check_if_patch_uptodate
	fi
}

download_update () {
	if [ ! -d "$UPDATE_DOWNLOAD_DIR" ]; then
		echo "ERROR: $UPDATE_DOWNLOAD_DIR is not a directory." >&2
		exit 1
	fi
	if [ ! -w "$UPDATE_DOWNLOAD_DIR" ]; then
		echo "ERROR: Cannot write to download directory $UPDATE_DOWNLOAD_DIR." >&2
		exit 1
	fi
	check_version
	if [ $NEW_GU_VERSION_AVAILABLE -eq 1 ]; then
		only_verbose echo "INFO: New version available: $LATEST_AVAILABLE_VERSION."
		only_verbose echo "INFO: Attempting to download new version."
		if "$TAHOE" get $SCRIPTURI/$LATEST_VERSION_FILENAME "$UPDATE_DOWNLOAD_DIR/$LATEST_VERSION_FILENAME" 2> /dev/null ; then
			echo "Update found (version $LATEST_AVAILABLE_VERSION) and downloaded to $UPDATE_DOWNLOAD_DIR/$LATEST_VERSION_FILENAME."
		fi
	else
		only_verbose echo "INFO: No new version available."
	fi
}

### Make NEWS.tgz ###

compile_news_tarball () {
	only_debug echo "DEBUG: Beginning of compile_news_tarball"
	PANDOC="$(which pandoc)"
	MARKDOWN="$(which markdown)"
	if [ -z $PANDOC ] && [ -z $MARKDOWN ]; then
		echo "ERROR: Could not find pandoc or markdown. Cannot --make-news."
		return 1
	fi
	# TODO install templates in /usr/share (use $DATADIR from webui branch)
	# TODO upload?
	NEWS_MARKDOWN_BASENAME="$(basename "$NEWS_MARKDOWN_SOURCE")"
	NEWS_PANDOC_TEMPLATE="$DATADIR"/pandoc-template.html
	NEWS_ATOM_TEMPLATE="$DATADIR"/NEWS.atom.template
	# Work in temporary directory
	NEWS_TMP_DIR=$(mktemp -d $LOCKDIR/grid-update.XXXX)
	cp "$NEWS_MARKDOWN_SOURCE" "$NEWS_TMP_DIR"/NEWS
	# Compile HTML
	if [ $PANDOC ]; then
		only_verbose echo "INFO: Compiling a NEWS.tgz tarball using pandoc."
		$PANDOC -s --template="$NEWS_PANDOC_TEMPLATE" -w html -r markdown \
			--email-obfuscation=none --output "$NEWS_TMP_DIR"/NEWS.html \
			"$NEWS_TMP_DIR"/NEWS
	elif [ $MARKDOWN ]; then
		only_verbose echo "INFO: Compiling a NEWS.tgz tarball using markdown."
		cat << EOF > "$NEWS_TMP_DIR"/NEWS.html
<html>
<head>
	<title>grid-updates</title>
	<link href="NEWS.atom" type="application/atom+xml" rel="alternate" title="grid-updates NEWS Atom Feed" />
	<style type="text/css">
	body {
		font-size: 80%;
	}
	h1 {
		font-size: 110%;
		font-family: sans-serif;
	}
	h2 {
		font-size: 90%;
		font-family: sans-serif;
	}
	</style>
</head>
<body>
EOF
		$MARKDOWN "$NEWS_TMP_DIR"/NEWS >> "$NEWS_TMP_DIR"/NEWS.html
		echo "</body>" >> "$NEWS_TMP_DIR"/NEWS.html
	fi
	# Create Atom news feed file
	sed -e "s/REPLACEUPDATED/$(date +%FT%T%:z)/" -e "s/REPLACEDATE/$(date -Ru)/" \
	-e "s/REPLACEID/urn:uuid$(uuid)/" "$NEWS_ATOM_TEMPLATE" > "$NEWS_TMP_DIR"/NEWS.atom
	# Create in TGZ file in PWD
	tar --directory "$NEWS_TMP_DIR" -c NEWS NEWS.html NEWS.atom | gzip -9 > NEWS.tgz
}

### Tahoe patch ###

find_webui_files () {
	if [ "$TAHOE" = "/usr/bin/tahoe" ] && [ -e /etc/debian_version ] ; then
		only_verbose echo "INFO: Debian package detected."
		WELCOME="/usr/share/pyshared/allmydata/web/welcome.xhtml"
		CSS="/usr/share/pyshared/allmydata/web/tahoe.css"
	else
		# This tries to find versions installed by the installer script.
		WELCOME="$(dirname $(which tahoe))/../src/allmydata/web/welcome.xhtml"
		CSS="$(dirname $(which tahoe))/../src/allmydata/web/tahoe.css"
	fi
	if [ ! -e "$WELCOME" ] || [ ! -e "$CSS" ]; then
		only_debug echo "DEBUG: Could not find web console files."
		return 1
	fi
}

webui_file_profile () {
	FILE="$1"
	if [ "$FILE" = "welcome.xhtml" ]; then
		export FILE_PATH="$WELCOME"
		export PATCH_FILE=$DATADIR/welcome.xhtml.patch
		export BACKUP_FILE=${FILE_PATH}.grid-updates.original
		export ORIG_CHECKSUM=$ORIGINAL_WEBUI_WELCOME_CHECKSUM
	elif [ "$FILE" = "tahoe.css" ]; then
		export FILE_PATH="$CSS"
		export PATCH_FILE=$DATADIR/tahoe.css.patch
		export BACKUP_FILE=${FILE_PATH}.grid-updates.original
		export ORIG_CHECKSUM=$ORIGINAL_WEBUI_CSS_CHECKSUM
	else
		echo "ERROR: Unknown file name."
		return 1
	fi
}

check_webui_file_permissions () {
	only_debug echo "DEBUG: Checking web console file permissions."
	if [ -f "$FILE_PATH" ]; then
		if [ ! -w "$FILE_PATH" ]; then
			echo "ERROR: No permission to write to $FILE."
			echo "ERROR: You may want run this command as the user who owns the Tahoe-LAFS installation."
			return 1
		else
			only_verbose echo "INFO: $FILE found and writable."
		fi
	else
		echo "ERROR: Not found: $FILE_PATH."
		return 1
	fi
	# Check the patches
	if [ ! -f "$PATCH_FILE" ]; then
		echo "ERROR: Patch for $FILE not found. Cannot apply patch."
		return 1
	fi
}

check_if_webui_patchable () {
	only_debug echo "DEBUG: Checking if web console file is patchable by grid-updates."
	# Compare files
	if [ "$(sha256sum "$FILE_PATH" | cut -d ' ' -f 1)" = "$ORIG_CHECKSUM" ]; then
		only_debug echo "DEBUG: $FILE still unpatched (known checksum)."
		# patch
		return 0
	else
		if grep -q "grid-updates" "$FILE_PATH" ; then
			# Check if patched by g-u.  (It could also differ because
			# of a new version of Tahoe. This shouldn't continue if we
			# don't understand why the file differs.)
			only_debug echo "DEBUG: File differs. Checking if it has been patched by grid-updates before."
			if [ -f "$BACKUP_FILE" ]; then
				# check if backup exists
				if [ "$(sha256sum "$BACKUP_FILE" | cut -d ' ' -f 1)" = "$ORIG_CHECKSUM" ]; then
					only_debug echo "DEBUG: Restoring backup in order to patch that."
					restore_webui_backup
					return 0
				else
					echo "ERROR: Backup file $FILE looks unexpected. Cannot apply patch."
					return 1
				fi
			fi
		else
			echo "ERROR: $FILE looks unexpected. Cannot apply patch."
			return 1
		fi
	fi
}

check_if_patch_uptodate () {
	if [ "$PATCHES_FOUND" = "y" ]; then
		only_debug echo "DEBUG: Checking for updates to the Tahoe web console patch."
		find_webui_files || return 1
		# It should suffice to check one of the files to be patched.
		webui_file_profile welcome.xhtml
		CURRENT_WEBUI_PATCH_VERSION=$(awk -F= '/<!-- Begin grid-updates patch/{getline; print $2}' "$DATADIR/welcome.xhtml.patch" )
		INSTALLED_WEBUI_PATCH_VERSION=$(awk -F= '/<!-- Begin grid-updates patch/{getline; print $2}' "$FILE_PATH")
		only_debug echo "DEBUG: Most current web console patch version: $CURRENT_WEBUI_PATCH_VERSION."
		only_debug echo "DEBUG: Currently installed web console patch version: $INSTALLED_WEBUI_PATCH_VERSION."
		if [ $INSTALLED_WEBUI_PATCH_VERSION ] && [ "$CURRENT_WEBUI_PATCH_VERSION" != "$INSTALLED_WEBUI_PATCH_VERSION" ]; then
			echo "There seems to be an updated web console patch available. Run grid-updates --patch-tahoe again to install it."
		else
			only_debug echo "DEBUG: No update to the web console patch available."
		fi
	else
		only_debug echo "DEBUG: Patches for Tahoe web console not found."
	fi
}

make_webui_backup () {
	if [ ! -f "$BACKUP_FILE" ]; then
		only_debug echo "DEBUG: Making a backup of $FILE_PATH."
		cp "$FILE_PATH" "$BACKUP_FILE"
	fi
}

restore_webui_backup () {
	if [ -f "$BACKUP_FILE" ]; then
		cp "$BACKUP_FILE" "$FILE_PATH"
		only_debug echo "DEBUG: Restoring web console backup file."
	else
		echo "ERROR: Couldn't find original backup file $BACKUP_FILE."
		return 1
	fi
}

apply_webui_patch () {
	only_debug echo "DEBUG: Applying patch to $FILE_PATH."
	patch "$FILE_PATH" < "$PATCH_FILE"
}

patch_webui_files () {
	only_verbose echo "INFO: Beginning to patch Tahoe web console."
	find_webui_files || return 1
	for FILE in "welcome.xhtml" "tahoe.css" ; do
		webui_file_profile $FILE
		check_webui_file_permissions || return 1
		check_if_webui_patchable || return 1
		make_webui_backup || return 1
		apply_webui_patch || return 1
	done \
		&& echo "Success: Patches successfully applied." \
		|| echo "ERROR: The Patches could not be applied. If your Tahoe console is inaccessible now, run \`grid-updates --undo-patch-tahoe\`."
}

restore_webui_files () {
	only_verbose echo "INFO: Beginning to restore original Tahoe web console."
	find_webui_files || return 1
	for FILE in "welcome.xhtml" "tahoe.css" ; do
		webui_file_profile $FILE
		check_webui_file_permissions
		restore_webui_backup
	done \
		&& echo "Success: Original Tahoe WebUI files restored." \
		|| echo "ERROR: Couldn't restore original WebUI files."
}

set -e          # abort if there are any uncaught errors along the way

### CLI option evaluation ###

while [ $# -gt 0 ] ; do
	case $1 in
		# Options
		--config|-c)
			if [ -z "$2" ]; then
				echo "ERROR: config file not specified." >&2
				print_help
				exit 1
			fi
			OPT_CONFIG_FILE=1
			SPECIFIED_CONFIG_FILE="$2"
			shift 2
			;;
		--node-directory|-d)
			if [ -z "$2" ]; then
				echo "ERROR: Tahoe node directory not specified." >&2
				print_help
				exit 1
			fi
			TAHOE_NODE_DIR=$2
			shift 2
			check_tahoe_node
			;;
		--list-uri)
			if [ -z "$2" ]; then
				echo "ERROR: list-uri not specified." >&2
				print_help
				exit 1
			fi
			LISTURI=$2
			shift 2
			check_uri "$LISTURI" "list"
			;;
		--news-uri)
			if [ -z "$2" ]; then
				echo "ERROR: news-uri not specified." >&2
				print_help
				exit 1
			fi
			NEWSURI=$2
			shift 2
			check_uri "$NEWSURI" "news"
			;;
		--script-uri)
			if [ -z "$2" ]; then
				echo "ERROR: script-uri not specified." >&2
				print_help
				exit 1
			fi
			SCRIPTURI=$2
			shift 2
			check_uri "$SCRIPTURI" "script"
			;;
		--download-tool)
			if [ -z "$2" ]; then
				echo "ERROR: download-tool not specified." >&2
				print_help
				exit 1
			fi
			DOWNLOAD_TOOL="$2"
			shift 2
			;;
		--no-proxy)
			OPT_NOPROXY=1
			shift
			;;
		--verbose|-v)
			OPT_VERBOSE=1
			shift
			;;
		--debug)
			OPT_DEBUG=1
			OPT_VERBOSE=1
			shift
			;;
		# Actions
		--merge-introducers|-m)
			OPT_MERGE_LIST=1
			shift
			;;
		--replace-introducers|-r)
			OPT_REPLACE_LIST=1
			shift
			;;
		--repair-subscriptions|-R)
			OPT_REPAIR_SUBSCRIPTIONS=1
			shift
			;;
		--download-news|-n)
			OPT_DOWNLOAD_NEWS=1
			shift
			;;
		--check-version)
			OPT_CHECK_VERSION=1
			shift
			;;
		--create-config|-C)
			if [ "$2" = "-v" ]; then
				# verbose doesn't make sense here so we'll just shift
				shift 2
			elif [ -z "$2" ]; then
				shift
			else
				CONFIG_FILE="$2"
				shift 2
			fi
			create_config_file
			;;
		--download-update)
			if [ -z "$2" ]; then
				only_verbose echo "INFO: No download directory specified. Using $PWD/."
				UPDATE_DOWNLOAD_DIR="$PWD"
				OPT_DOWNLOAD_UPDATE=1
				shift
			else
				UPDATE_DOWNLOAD_DIR="$2"
				OPT_DOWNLOAD_UPDATE=1
				shift 2
			fi
			;;
		--make-news)
			if [ -z "$2" ]; then
				echo "ERROR: No Markdown source file specified." >&2
				print_help
				exit 1
			fi
			OPT_COMPILE_NEWS=1
			NEWS_MARKDOWN_SOURCE="$2"
			shift 2
			;;
		--patch-tahoe)
			OPT_PATCH_TAHOE=1
			shift
			;;
		--undo-patch-tahoe)
			OPT_UNDO_PATCH_TAHOE=1
			shift
			;;
		--version|-V)
			echo "$(basename $0) version: $VERSION"
			http_download
			exit 0
			;;
		--help|-h)
			print_help
			exit
			;;
		*)
			echo "$0: invalid command -- '$1'" >&2
			print_help
			exit 1
			;;
	esac
done

### Tasks and checks to be run before any action ###

# Stop multiple instances from running simultaneously #
if [ -w /var/lock ]; then  # the default lock directory in Linux
        LOCKDIR="/var/lock/grid-updates.lck"
else
        LOCKDIR="/tmp/grid-updates.lck"   # but maybe not elsewhere...
fi
PIDFILE="${LOCKDIR}/PID"
ENO_SUCCESS=0;
ENO_GENERAL=1;
ENO_LOCKFAIL=2;
ENO_RECVSIG=3;

if mkdir "${LOCKDIR}"  > /dev/null 2>&1 ; then
       trap 'ECODE=$?;
       rm -rf "${LOCKDIR}"' 0
       touch $PIDFILE
       echo $$ > "${PIDFILE}"
       trap 'echo "ERROR: Killed by a signal $ECODE $ENO_RECVSIG" >&2
            exit ${ENO_RECVSIG}' 1 2 3 15
else
       # lock failed, check if it's stale
       OTHERPID="$(cat "${PIDFILE}")"

       if [ $? != 0 ]; then
               echo "ERROR: Another instance of `basename $0` is active with PID ${OTHERPID}" >&2
               exit ${ENO_LOCKFAIL}
       fi
       if ! kill -0 ${OTHERPID} >/dev/null 2>&1; then
               #stale lock, removing it and restarting
               only_verbose echo "INFO: Removing stale PID ${OTHERPID}" >&2
               rm -rf ${LOCKDIR} || echo "Cannot remove $LOCKDIR" >&2; exit 1
               only_verbose echo "INFO: [`basename $0`] restarting" >&2
               exec "$0" "$@"
       else
               #lock is valid and OTHERPID is active
               echo "ERROR: Another instance of `basename $0` is active with PID ${OTHERPID}" >&2
               exit ${ENO_LOCKFAIL}
       fi
fi

# Find tahoe executable
TAHOE=$(which tahoe) || (echo "ERROR: \`tahoe\` executable not found." >&2 && exit 1)

# Find data dir
BINDIR="$(dirname $(which $0))"
if [ "$BINDIR" = "/usr/bin" ] || [ "$BINDIR" = "/usr/local/bin" ]; then
	DATADIR="$BINDIR/../share/grid-updates"
else
	# if script is run directly and not installed
	DATADIR="$BINDIR/etc"
fi
only_debug echo "DEBUG: Determined that location of grid-updates data directory is $DATADIR."

# Parse config files
read_config_files

# Check for patch files
if [ -e "$DATADIR/welcome.xhtml.patch" ]; then
	PATCHES_FOUND=y
else
	PATCHES_FOUND=n
fi

# Debug output (should probably be removed again)
only_debug echo "DEBUG: Using Tahoe node dir: $TAHOE_NODE_DIR"

export http_proxy
only_debug echo "DEBUG: Using HTTP proxy $http_proxy."

# Always check for valid Tahoe node directory.
# TODO If this stays we can remove a bunch of later checks.
check_tahoe_node

# Always check NEWS.html exists. Create a placeholder if it doesn't.
check_newshtml_exists

### Run selected actions ###

# Check if an obligatory option has been specified:
if [ $OPT_MERGE_LIST ] || [ $OPT_REPLACE_LIST ] || \
[ $OPT_REPAIR_SUBSCRIPTIONS ] || [ $OPT_DOWNLOAD_NEWS ] || \
[ $OPT_CHECK_VERSION ] || [ $OPT_DOWNLOAD_UPDATE ] || \
[ $OPT_PATCH_TAHOE ] || [ $OPT_UNDO_PATCH_TAHOE ] || \
[ $OPT_COMPILE_NEWS ];
then
	[ $OPT_REPAIR_SUBSCRIPTIONS ] && repair_subscriptions
	# Make sure no conflicting options have been specified:
	if [ $OPT_MERGE_LIST ] && [ ! $OPT_REPLACE_LIST ]; then
		merge_list
	elif [ ! $OPT_MERGE_LIST ] && [ $OPT_REPLACE_LIST ]; then
		replace_list
	elif [ $OPT_MERGE_LIST ] && [ $OPT_REPLACE_LIST ]; then
		echo "ERROR: --merge-introducers and --replace-introducers are mutually exclusive." >&2
		print_help
		exit 1
	fi
	if [ $OPT_DOWNLOAD_NEWS ]; then
		download_news
		check_if_patch_uptodate
	fi
	# Only run download_update if both --check-version and --download-update
	# have been specified:
	if [ $OPT_CHECK_VERSION ] && [ $OPT_DOWNLOAD_UPDATE ]; then
		download_update
	elif [ $OPT_DOWNLOAD_UPDATE ]; then
		download_update
	elif [ $OPT_CHECK_VERSION ]; then
		check_version
	fi
	if [ $OPT_COMPILE_NEWS ]; then
		compile_news_tarball && \
		echo "Success: created NEWS.tgz."
	fi
	# Tahoe WebUI patch
	if [ $OPT_PATCH_TAHOE ] && [ ! $OPT_UNDO_PATCH_TAHOE ]; then
		patch_webui_files
	elif [ ! $OPT_PATCH_TAHOE ] && [ $OPT_UNDO_PATCH_TAHOE ]; then
		restore_webui_files
	elif [ $OPT_PATCH_TAHOE ] && [ $OPT_UNDO_PATCH_TAHOE ]; then
		echo "ERROR: --patch-tahoe and --undo-patch-tahoe are mutually exclusive." >&2
		print_help
		exit 1
	fi
else
	echo "ERROR: You need to specify an action." >&2
	print_help
	exit 1
fi

exit 0
