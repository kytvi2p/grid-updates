#!/bin/sh

# grid-updates -- a helper script for a Tahoe-LAFS nodes
#
#
# Authors:
#     darrob <darrob@mail.i2p>
#     KillYourTV <kytv@mail.i2p>
#
# License: public domain
#
# Requirements:
#     Bourne-compatible shell, Tahoe-LAFS

# For more information see the README.md and INSTALL.md files.

# This script's version:
VERSION='0.4.1-git'

################################## DEFAULTS ###################################
# Default location of the Tahoe-LAFS node:
DEFAULT_TAHOE_NODE_DIR="$HOME/.tahoe"
# Default location (directory) of the subscription list:
DEFAULT_LISTURI='URI:DIR2-RO:t4fs6cqxaoav3r767ce5t6j3h4:gvjawwbjljythw4bjhgbco4mqn43ywfshdi2iqdxyhqzovrqazua'
# Default location (directory) of the NEWS file:
DEFAULT_NEWSURI='URI:DIR2-RO:hx6754mru4kjn5xhda2fdxhaiu:hbk4u6s7cqfiurqgqcnkv2ckwwxk4lybuq3brsaj2bq5hzajd65q'
# Default location (directory) of script releases:
DEFAULT_SCRIPTURI='URI:DIR2-RO:mjozenx3522pxtqyruekcx7mh4:eaqgy2gfsb73wb4f4z2csbjyoh7imwxn22g4qi332dgcvfyzg73a'
DEFAULT_HTTP_PROXY='127.0.0.1:4444'
###############################################################################

[ -z "$XDG_CONFIG_HOME" ] && XDG_CONFIG_HOME="$HOME/.config"
[ -z "$XDG_CONFIG_DIRS" ] && XDG_CONFIG_DIRS="/etc/xdg"

only_verbose () {
	if [ $OPT_VERBOSE ]; then
		$@
	fi
}

pretty_print () {
	while read line ; do echo "$line" | sed 's/^/INFO:\ \ \ \ /'; done
}

checking_failed ()
{
	echo "ERROR: failed to check $1 share." >&2
	return 1
}

# http://unix.derkeiler.com/Newsgroups/comp.unix.shell/2005-06/1079.html
run () {
	j=1
	while eval "\${pipestatus_$j+:} false"; do
		unset pipestatus_$j
		j=$(($j+1))
	done
	j=1 com= k=1 l=
	for a; do
		if [ "x$a" = 'x|' ]; then
			com="$com { $l "'3>&-
				echo "pipestatus_'$j'=$?" >&3
					} 4>&- |'
			j=$(($j+1)) l=
		else
			l="$l \"\$$k\""
		fi
		k=$(($k+1))
	done
	com="$com $l"' 3>&- >&4 4>&-
			echo "pipestatus_'$j'=$?"'
	exec 4>&1
	eval "$(exec 3>&1; eval "$com")"
	exec 4>&-
	j=1
	while eval "\${pipestatus_$j+:} false"; do
		eval "[ \$pipestatus_$j -eq 0 ]" || return 1
		j=$(($j+1))
	done
	return 0
}

version_to_decimal () {
	echo "$@" | awk -F. '{ printf("%d%03d%03d\n", $1,$2,$3); }';
}


if [ -z $I2P ]; then
	if [ -e /usr/share/i2p/lib/i2p.jar ]; then
		I2P="/usr/share/i2p"
	elif [ -e $HOME/i2p/lib/i2p.jar ]; then
		I2P="$HOME/i2p"
	else
		I2P="nfc"
	fi
fi

if [ ! $I2P = "nfc"  ]; then
	I2PVERSION=$(java -cp $I2P/lib/i2p.jar net.i2p.CoreVersion | awk -F' ' '/version/{print $4}') > /dev/null 2>&1
	if [ $(version_to_decimal $I2PVERSION) -gt $(version_to_decimal 0.8.12) ]; then
		FIXED_EEP="true"
	elif [ $(version_to_decimal $I2PVERSION) -eq $(version_to_decimal 0.8.12) ] && [ "$I2P" = "/usr/share/i2p" ] ; then
		FIXED_EEP="true"
	else
		FIXED_EEP="false"
	fi
fi

EEPGET="java -jar $I2P/lib/i2p.jar net.util.EepGet"

# Stop multiple instances from running simultaneously
if [ -w /var/lock ]; then  # the default lock directory in Linux
        LOCKDIR="/var/lock/grid-updates.lck"
else
        LOCKDIR="/tmp/grid-updates.lck"   # but maybe not elsewhere...
fi
PIDFILE="${LOCKDIR}/PID"
ENO_SUCCESS=0;
ENO_GENERAL=1;
ENO_LOCKFAIL=2;
ENO_RECVSIG=3;

if mkdir "${LOCKDIR}"  > /dev/null 2>&1 ; then
       trap 'ECODE=$?;
       rm -rf "${LOCKDIR}"' 0
       touch $PIDFILE
       echo $$ > "${PIDFILE}"
       trap 'echo "ERROR: Killed by a signal $ECODE $ENO_RECVSIG" >&2
            exit ${ENO_RECVSIG}' 1 2 3 15
else
       # lock failed, check if it's stale
       OTHERPID="$(cat "${PIDFILE}")"

       if [ $? != 0 ]; then
               echo "ERROR: Another instance of `basename $0` is active with PID ${OTHERPID}" >&2
               exit ${ENO_LOCKFAIL}
       fi
       if ! kill -0 ${OTHERPID} >/dev/null 2>&1; then
               #stale lock, removing it and restarting
               only_verbose echo "INFO: Removing stale PID ${OTHERPID}" >&2
               rm -rf ${LOCKDIR} || echo "Cannot remove $LOCKDIR" >&2; exit 1
               only_verbose echo "INFO: [`basename $0`] restarting" >&2
               exec "$0" "$@"
       else
               #lock is valid and OTHERPID is active
               echo "ERROR: Another instance of `basename $0` is active with PID ${OTHERPID}" >&2
               exit ${ENO_LOCKFAIL}
       fi
fi

print_help () {
cat << EOF

Usage: $0 [OPTIONS] [ACTIONS]

Actions:
    -m, --merge-introducers     Merge your local introducers list with the
                                subscription's
    -r, --replace-introducers   Replace your local list of introducers with the
                                master list
    -n, --download-news         Retrieve news regarding the I2P grid.  These
                                will be stored in [node directory]/NEWS.
                                If you run this script as a cron job, the
                                news will also be emailed to you.
    --check-version             Check for a new version of this script on the
                                grid
    --download-update           Download a new version of this script from the
        [target directory]      grid (implies --check-version)
    -R, --repair-subscriptions  Maintain or repair the health of the subscription
                                service's URI
Options:
    -c [config file],           Specify a grid-updates config file
    --config [config file]
    -d [directory],             Specify the node directory (default: ~/.tahoe)
    --node-directory [directory]
    --list-uri [URI]            Override default location of introducers
                                list
    --news-uri [URI]            Override default location of news file
    --script-uri [URI]          Override default location of script updates
    --no-proxy                  Disable proxy when downloading from non-tahoe
                                URIs
    -v, --verbose               Display more verbose output
    -V, --version               Display version information
    -h, --help                  Print this help text

Errors:
    If the script repeatedly fails to retrieve a file from the grid, the share
    may be damaged.  See the ERRORS section in the man page (\`man
    grid-updates\`) for solutions.

EOF
}

TAHOE=$(which tahoe)
[ -z "$TAHOE" ] && echo "ERROR: \`tahoe\` executable not found." >&2 && exit 1

# Abort if any variables aren't initialized to try to prevent any surprises
set -o nounset  # same as set -u
set -e          # abort if there are any uncaught errors along the way

### config files ###

parse_config_item () {
	OPTION=$1
	if grep -q "^$OPTION" $CONFIG_FILE ; then
		# XXX: are these regex's too broad?
		PARSED_OPTION=$(grep --max-count=1 "^$OPTION" $CONFIG_FILE |
			sed -e s/[\"\']//g -e 's/^\w\+[\ \t]*=[\ \t]*\(.*\)$/\1/')
		if [ -z "$PARSED_OPTION" ]; then
			echo "WARNING: Illegal value for '$OPTION' in $CONFIG_FILE. Ignoring it."
		else
			eval "PARSED_$OPTION=$PARSED_OPTION"
			export "PARSED_$OPTION"
		fi
	fi
	unset PARSED_OPTION
}

parse_config_file () {
	# Parse option if available
	parse_config_item "LISTURI"
	parse_config_item "NEWSURI"
	parse_config_item "SCRIPTURI"
	parse_config_item "TAHOE_NODE_DIR"
	parse_config_item "HTTP_PROXY"
	parse_config_item "NO_PROXY"
	# Set parsed value if option is still unset
	if [ -z $LISTURI ] && [ -n $PARSED_LISTURI ]; then
		LISTURI="$PARSED_LISTURI"
	fi
	if [ -z $NEWSURI ] && [ -n $PARSED_NEWSURI ]; then
		NEWSURI="$PARSED_NEWSURI"
	fi
	if [ -z $SCRIPTURI ] && [ -n $PARSED_SCRIPTURI ]; then
		SCRIPTURI="$PARSED_SCRIPTURI"
	fi
	if [ -z $TAHOE_NODE_DIR ] && [ -n $PARSED_TAHOE_NODE_DIR ]; then
		TAHOE_NODE_DIR="$PARSED_TAHOE_NODE_DIR"
	fi
	if [ -z $http_proxy ] && [ -n $PARSED_HTTP_PROXY ]; then
		http_proxy="$PARSED_HTTP_PROXY"
	fi
	if [ "$PARSED_NO_PROXY" = "yes" ]; then
		OPT_NOPROXY=1
	fi
	return 0
}

read_config_files () {
	# Parse specified config file (--config)
	if [ $OPT_CONFIG_FILE ] ; then
		CONFIG_FILE="$SPECIFIED_CONFIG_FILE"
		if [ -f "$CONFIG_FILE" ]; then
			parse_config_file
		else
			echo "ERROR: Config file $CONFIG_FILE not found."
			exit 1
		fi
	fi
	# Parse files in standard locations if available
	if [ -f $XDG_CONFIG_HOME/grid-updates/config ]; then
		CONFIG_FILE="$XDG_CONFIG_HOME/grid-updates/config"
		parse_config_file
	fi
	if [ -f $XDG_CONFIG_DIRS/grid-updates/config ]; then
		CONFIG_FILE="$XDG_CONFIG_DIRS/grid-updates/config"
		parse_config_file
	fi
	# Apply default values where necessary
	[ -z $LISTURI ] && LISTURI="$DEFAULT_LISTURI"
	[ -z $NEWSURI ] && NEWSURI="$DEFAULT_NEWSURI"
	[ -z $SCRIPTURI ] && SCRIPTURI="$DEFAULT_SCRIPTURI"
	[ -z $TAHOE_NODE_DIR ] && TAHOE_NODE_DIR="$DEFAULT_TAHOE_NODE_DIR"
	[ -z $http_proxy ] && http_proxy="$DEFAULT_HTTP_PROXY"
	return 0
}

### checks ###

check_tahoe_node () {
	if [ -d "$TAHOE_NODE_DIR" ]; then
		if [ ! -e $TAHOE_NODE_DIR/node.url ]; then
			echo "ERROR: Cannot find $TAHOE_NODE_DIR/node.url. Not a valid tahoe node." >&2
			exit 1
		fi
		return 0
	else
		echo "ERROR: $TAHOE_NODE_DIR is not a directory." >&2
		exit 1
	fi
}

check_permissions () {
	if [ ! -w "$TAHOE_NODE_DIR" ]; then
		echo "ERROR: Need write permissions to "$TAHOE_NODE_DIR" to be able to update "$1"" >&2
		exit 1
	fi
	if [ -e "$2" ] && [ ! -w "$2" ]; then
		echo "ERROR: Need write permissions to \"$2\" to be able to update "$1"" >&2
		exit 1
	fi
}

check_uri () {
	# Tahoe URIs will start with URI:
	#Yes, this is very rudimentary checking,
	# but it's better than nothing...isn't it?
	if [ ! $(echo "$1" | grep '^URI:') ] && [ ! $(echo "$1" | egrep '^http:') ] ; then
		echo "ERROR: "$1" is not a valid ${2}-uri." >&2
		return 1
	fi
}

eep_get () {
	DL_REMOTE_LOCATION="$1"
	DL_TARGET_LOCATION="$2"
	DL_REMOTE_NAME="$3"
	if [ $OPT_NOPROXY ]; then
		unset http_proxy
	fi
	if [ "$FIXED_EEP" = "true"  ]; then
		EEPTOOL="$EEPGET"
		if [ $OPT_NOPROXY ]; then
			EEPFETCHCMD="${EEPTOOL} -n 2 ${DL_REMOTE_LOCATION} -o ${DL_TARGET_LOCATION} -p :0"
		else
			EEPFETCHCMD="${EEPTOOL} -n 2 ${DL_REMOTE_LOCATION} -o ${DL_TARGET_LOCATION} -p ${http_proxy}"
		fi
	elif [ $(which wget) ]; then
		EEPTOOL="wget"
		EEPFETCHCMD="${EEPTOOL} --tries=2 --quiet ${DL_REMOTE_LOCATION} -O ${DL_TARGET_LOCATION}"
	elif [ $(which fetch) ]; then
		EEPTOOL="fetch"
		EEPFETCHCMD="${EEPTOOL} -q -o ${DL_TARGET_LOCATION} ${DL_REMOTE_LOCATION}"
	elif [ $(which curl) ]; then
		EEPTOOL="curl"
		EEPFETCHCMD="${EEPTOOL} -s --retry 2 -L ${DL_REMOTE_LOCATION} -o ${DL_TARGET_LOCATION}"
	else
		echo "ERROR: Couldn't find a tool capable of retrieving files from eepsites." >&2
		return 1
	fi

	if [ x${DL_REMOTE_LOCATION} = "x" ]; then
		# We'll only arrive here if eep_get is called
		# without any parameters. For potential future
		# use.
		echo "Detected $EEPTOOL"
		if [ ! -z $I2PVERSION ]; then
			echo "I2PVERSION: $I2PVERSION"
			echo "FIXED_EEP: $FIXED_EEP"
		fi
	else
		if [ $OPT_NOPROXY ]; then
			only_verbose echo "INFO: Attempting to download $DL_REMOTE_NAME using ${EEPTOOL} (no proxy)."
		else
			only_verbose echo "INFO: Attempting to download $DL_REMOTE_NAME using ${EEPTOOL} (proxy ${http_proxy})."
		fi
		$EEPFETCHCMD > /dev/null 2>&1
		if [ $? -gt 0 ]; then
			echo "ERROR: Failed to retrieve $DL_REMOTE_NAME from $1." >&2
			return 1
		fi
	fi
}

#### introducers ####

filter_furls () {
	grep --no-filename -e '^pb://[a-zA-Z0-9-]\+@.\+/.\+$' $@
}

download_list () {
	DLLIST=$(mktemp $LOCKDIR/grid-update.XXXX)
	TMPLIST=$(mktemp $LOCKDIR/grid-update.XXXX)
	if [ $(echo $LISTURI |egrep '^http:') ]; then
		if ! eep_get "${LISTURI}/introducers" "$DLLIST" "subscriptions"; then
			echo "ERROR: Could not retrieve the list from $LISTURI." >&2
			return 1
		fi
		filter_furls $DLLIST | sort -u > "$TMPLIST"
	else
		only_verbose echo "INFO: Attempting to download introducers list from the grid ($LISTURI)."
		if ! "$TAHOE" get "$LISTURI"/introducers "$TMPLIST" 2> /dev/null ; then
			echo "ERROR: Could not retrieve the list. Try again or check the share's integrity. See \`$0 --help.\`" >&2
			return 1
		fi
		filter_furls $DLLIST | sort -u > "$TMPLIST"
	fi
}

backup_list () {
	if [ -e "$INTRODUCER_LIST" ]; then
		LISTBAK="$INTRODUCER_LIST.bak"
		if [ ! -w "$LISTBAK" ] && ! touch "$LISTBAK" 2> /dev/null ; then
			echo "ERROR: Need write permissions to $LISTBAK to be able to update the file." >&2
			exit 1
		fi
		echo "# This is a backup of "$INTRODUCER_LIST". It was created by `basename $0` on $(date -u)." > "$LISTBAK"
		cat "$INTRODUCER_LIST" >> "$LISTBAK"
		return 0
	fi
}

merge_list () {
	INTRODUCER_LIST="$TAHOE_NODE_DIR/introducers"
	TMPLIST2=$(mktemp $LOCKDIR/grid-update.XXXX)
	if [ ! -e "$INTRODUCER_LIST" ]; then
		only_verbose echo "INFO: Unable to find "$INTRODUCER_LIST". Retrieving a new list."
		replace_list
		return 0
	else
		# Add new URIs in the subscribed list to the local list.
		# This resembles I2P's address book's system.
		check_permissions "the subscription list" "$INTRODUCER_LIST"
		download_list
		backup_list
		filter_furls "$INTRODUCER_LIST.bak" "$TMPLIST" | sort -u > "$TMPLIST2"
		if diff -N "$TMPLIST2" "$INTRODUCER_LIST" > /dev/null 2>&1 ; then
			only_verbose echo "INFO: No new introducers found."
			return 0
		else
		filter_furls "$INTRODUCER_LIST.bak" "$TMPLIST" | sort -u > "$INTRODUCER_LIST" # merge
			only_verbose echo "INFO: Success: the list has been retrieved and merged. (Changes will take effect upon restart of the node.)"
		fi
		return 0
	fi
}

replace_list () {
	INTRODUCER_LIST="$TAHOE_NODE_DIR/introducers"
	# Make the local list identical to the subscribed one.
	check_permissions "the subscription list" "$INTRODUCER_LIST"
	download_list
	backup_list
	if diff -N "$LISTBAK" "$INTRODUCER_LIST" > /dev/null 2>&1; then
		mv -f "$TMPLIST" "$INTRODUCER_LIST" > /dev/null 2>&1   # install list
		only_verbose echo "INFO: Success: the list has been retrieved. (Changes will take effect upon restart of the node.)"
	elif [ ! -e "$INTRODUCER_LIST" ]; then # if we're here there was a back up but no introducer list
		mv -f "$TMPLIST" "$INTRODUCER_LIST" > /dev/null 2>&1   # install list
		only_verbose echo "INFO: Success: the list has been retrieved. (Changes will take effect upon restart of the node.)"
	else
		only_verbose echo "INFO: No updates available."
	fi
	return 0
}

#### news ####

check_pubhtml_permissions () {
	if [ ! $WEB_STATIC ]; then
		echo "Error: could not find 'web.static' option in $TAHOE_CFG." >&2
		return 1
	fi
	if [ ! -r $TAHOE_CFG ]; then
		echo "Error: cannot read $TAHOE_CFG." >&2
		return 1
	fi
	if [ ! -w "$PUB_HTML_DIR" ]; then
		if ! mkdir $PUB_HTML_DIR ; then
			echo "Error: cannot write to or create $PUB_HTML_DIR." >&2
			return 1
		fi
	fi
}

check_newshtml_exists () {
	TAHOE_CFG="$TAHOE_NODE_DIR/tahoe.cfg"
	WEB_STATIC="$(sed -e '/^web\.static/!d' -e 's/^web\.static\ *=\ *//' $TAHOE_CFG)"
	PUB_HTML_DIR="$TAHOE_NODE_DIR/$WEB_STATIC"
	if [ ! -e $PUB_HTML_DIR/NEWS.html ]; then
		check_pubhtml_permissions
		make_newshtml_placeholder > $PUB_HTML_DIR/NEWS.html
	fi
}

make_newshtml_placeholder () {
cat << EOF
<html><head></head><body><small>
	<p>
		This space if for news items downloaded by
		<tt><strong>grid-updates</strong></tt>.
	</p>
	<p>
		Please run <tt>grid-updates --download-news</tt> to download the latest
		news files from the Tahoe-LAFS grid. See the README and man page for
		more information.
	</p>
	<p>
		If you haven't installed <tt>grid-updates</tt> already, please consider
		doing so.
		You can obtain it from the following locations:
		<ul>
			<li><a href="http://git.repo.i2p/w/grid-updates.git">http://git.repo.i2p/w/grid-updates.git</a></li>
			<li>
				<a href='http://127.0.0.1:3456/uri/URI%3ADIR2-RO%3Amjozenx3522pxtqyruekcx7mh4%3Aeaqgy2gfsb73wb4f4z2csbjyoh7imwxn22g4qi332dgcvfyzg73a/'>URI:DIR2-RO:mjozenx3522pxtqyruekcx7mh4:eaqgy2gfsb73wb4f4z2csbjyoh7imwxn22g4qi332dgcvfyzg73a</a>
			</li>
		</ul>
	</p>
</small></body></html>
EOF
}

print_news () {
	# if new NEWS...
	if ! diff -N "$TAHOE_NEWS" "$TMP_NEWS_PLAIN" > /dev/null ; then
		# move old news aside
		if [ -e "$TAHOE_NEWS" ]; then
			cp -f "$TAHOE_NEWS" "$OLD_NEWS"
		fi
		# put new news into place
		cp -f "$TMP_NEWS_PLAIN" "$TAHOE_NEWS" > /dev/null
		# print
		diff --ignore-all-space --ignore-blank-lines --new-file \
			"$OLD_NEWS" "$TAHOE_NEWS" | sed -e '/^>/!d' -e 's/^>\ //'
		# Copy HTML version into place
		cp -f $TMP_NEWS_DIR/NEWS.html $PUB_HTML_DIR/NEWS.html
		return 0
	else
		only_verbose echo "INFO: There are no news."
		# Copy HTML version into place
		cp -f $TMP_NEWS_DIR/NEWS.html $PUB_HTML_DIR/NEWS.html
		return 0
	fi
}

download_news () {
	TAHOE_NEWS="$TAHOE_NODE_DIR/NEWS"
	check_permissions "news" "$TAHOE_NEWS"
	TMP_NEWS_TGZ=$(mktemp $LOCKDIR/grid-update.XXXX)
	TMP_NEWS_DIR=$(mktemp -d $LOCKDIR/grid-update.XXXX)
	TMP_NEWS_PLAIN="$TMP_NEWS_DIR/NEWS"
	OLD_NEWS=$(mktemp $LOCKDIR/grid-update.XXXX)
	check_pubhtml_permissions
	if [ $(echo $NEWSURI |egrep '^http:') ]; then
		if eep_get "${NEWSURI}/NEWS.tgz" "$TMP_NEWS_DIR/NEWS.tgz" "news"; then
			tar xzf "$TMP_NEWS_DIR/NEWS.tgz" --directory "$TMP_NEWS_DIR"
			print_news
			return 0
		else
			echo "ERROR: Could not retrieve the news from $NEWSURI." >&2
			return 1
		fi
	else
		only_verbose echo "INFO: Attempting to download the NEWS.tgz file from the grid ($NEWSURI)."
		if "$TAHOE" get "$NEWSURI/NEWS.tgz" "$TMP_NEWS_DIR/NEWS.tgz" 2> /dev/null ; then
			tar xzf "$TMP_NEWS_DIR/NEWS.tgz" --directory "$TMP_NEWS_DIR"
			print_news
			return 0
		else
			echo "ERROR: Couldn't fetch the NEWS file." >&2
			exit 1
		fi
	fi
}

#### Tahoe deep-check ####

deep_check () {
	if [ $OPT_VERBOSE ]; then
		run "$TAHOE" deep-check -v --repair --add-lease "$1" 2>/dev/null >&1 \| pretty_print
		return $pipestatus_1 # return exit value of `tahoe deep-check`
	else
		"$TAHOE" deep-check --repair --add-lease "$1" >/dev/null 2>&1
	fi
}

repair_subscriptions () {
	check_tahoe_node
	only_verbose echo "INFO: Beginning to check subscription shares."
	only_verbose echo "INFO: Checking subscription share (1/3)."
	deep_check "$LISTURI" || checking_failed "subscriptions"
	only_verbose echo "INFO: Checking NEWS share (2/3)."
	deep_check "$NEWSURI" || checking_failed "news"
	only_verbose echo "INFO: Checking scripts share (3/3)."
	deep_check "$SCRIPTURI" || checking_failed "scripts"
}

#### version / update check ####

check_version () {
	if [ $(echo $SCRIPTURI |egrep '^http:') ]; then
		echo "ERROR: Script updates are not currently supported from eepSites." >&2
		return 1
	fi
	LC_ALL=C # make sure sort order is what we expect
	only_verbose echo "INFO: Attempting to check for new version (in $SCRIPTURI)."
	# sort -V not on FreeBSD. These sort parameters were taken from http://stackoverflow.com/a/4046149
	LATEST_VERSION_FILENAME=$("$TAHOE" ls $SCRIPTURI | grep 'grid-updates-v[[:digit:]]\.[[:digit:]].*\.tgz' | sort -r -V | head -n 1)
	if [ "$LATEST_VERSION_FILENAME" ]; then
		LATEST_AVAILABLE_VERSION=$(echo $LATEST_VERSION_FILENAME | sed 's/^grid-updates-v\(.*\)\.tgz$/\1/')
		if [ $(uname -s |tr \[A-Z\] \[a-z\]) != "linux" ]; then
			NEWEST_VERSION=$(echo -e "$VERSION\n$LATEST_AVAILABLE_VERSION" | sort -r -V | head -n 1)
		else
			NEWEST_VERSION=$(/bin/echo -e "$VERSION\n$LATEST_AVAILABLE_VERSION" | sort -r -V | head -n 1)
		fi
		if [ "$VERSION" != "$NEWEST_VERSION" ]; then
			# Only print if not called via --download-update
			[ ! $OPT_DOWNLOAD_UPDATE ] && echo "New version available: $LATEST_AVAILABLE_VERSION."
			return 0
		else
			# Only print if not called via --download-update
			[ ! $OPT_DOWNLOAD_UPDATE ] && echo "No new version available."
			return 1
		fi
	else
		echo "Error: Nothing found. This doesn't seem to be a download location for grid-updates." >&2
	fi
}

download_update () {
	if [ ! -d $UPDATE_DOWNLOAD_DIR ]; then
		echo "ERROR: $UPDATE_DOWNLOAD_DIR is not a directory." >&2
		exit 1
	fi
	if [ ! -w $UPDATE_DOWNLOAD_DIR ]; then
		echo "ERROR: Cannot write to download directory $UPDATE_DOWNLOAD_DIR." >&2
		exit 1
	fi
	if check_version; then
		only_verbose echo "INFO: New version available: $LATEST_AVAILABLE_VERSION."
		only_verbose echo "INFO: Attempting to download new version."
		if "$TAHOE" get $SCRIPTURI/$LATEST_VERSION_FILENAME "$UPDATE_DOWNLOAD_DIR/$LATEST_VERSION_FILENAME" 2> /dev/null ; then
			echo "Update found (version $LATEST_AVAILABLE_VERSION) and downloaded to $UPDATE_DOWNLOAD_DIR/$LATEST_VERSION_FILENAME."
		fi
	else
		only_verbose echo "INFO: No new version available."
	fi
}

# some of those variables will not be initialized--and that's OK.
# We'll do our own checking from this point forward.
set +u

### CLI option evaluation ###

while [ $# -gt 0 ] ; do
	case $1 in
		# Options
		--config|-c)
			if [ -z "$2" ]; then
				echo "ERROR: config file not specified." >&2
				print_help
				exit 1
			fi
			OPT_CONFIG_FILE=1
			SPECIFIED_CONFIG_FILE="$2"
			shift 2
			;;
		--node-directory|-d)
			if [ -z "$2" ]; then
				echo "ERROR: Tahoe node directory not specified." >&2
				print_help
				exit 1
			fi
			TAHOE_NODE_DIR=$2
			shift 2
			check_tahoe_node
			;;
		--list-uri)
			if [ -z "$2" ]; then
				echo "ERROR: list-uri not specified." >&2
				print_help
				exit 1
			fi
			LISTURI=$2
			shift 2
			check_uri "$LISTURI" "list"
			;;
		--news-uri)
			if [ -z "$2" ]; then
				echo "ERROR: news-uri not specified." >&2
				print_help
				exit 1
			fi
			NEWSURI=$2
			shift 2
			check_uri "$NEWSURI" "news"
			;;
		--script-uri)
			if [ -z "$2" ]; then
				echo "ERROR: script-uri not specified." >&2
				print_help
				exit 1
			fi
			SCRIPTURI=$2
			shift 2
			check_uri "$SCRIPTURI" "script"
			;;
		--no-proxy)
			OPT_NOPROXY=1
			shift
			;;
		--verbose|-v)
			OPT_VERBOSE=1
			shift
			;;
		# Actions
		--merge-introducers|-m)
			OPT_MERGE_LIST=1
			shift
			;;
		--replace-introducers|-r)
			OPT_REPLACE_LIST=1
			shift
			;;
		--repair-subscriptions|-R)
			OPT_REPAIR_SUBSCRIPTIONS=1
			shift
			;;
		--download-news|-n)
			OPT_DOWNLOAD_NEWS=1
			shift
			;;
		--check-version)
			OPT_CHECK_VERSION=1
			shift
			;;
		--download-update)
			if [ -z "$2" ]; then
				only_verbose echo "INFO: No download directory specified. Using $PWD/."
				UPDATE_DOWNLOAD_DIR="$PWD"
				OPT_DOWNLOAD_UPDATE=1
				shift
			else
				UPDATE_DOWNLOAD_DIR="$2"
				OPT_DOWNLOAD_UPDATE=1
				shift 2
			fi
			;;
		--version|-V)
			echo "$(basename $0) version: $VERSION"
			eep_get
			exit 0
			;;
		--help|-h)
			print_help
			exit
			;;
		*)
			echo "ERROR: Unknown command." >&2
			print_help
			exit 1
			;;
	esac
done

### Tasks and checks to be run before any action ###

# Parse config files
read_config_files

# Debug output (should probably be removed again)
only_verbose echo "INFO: Using Tahoe node dir: $TAHOE_NODE_DIR"

export http_proxy

# Always check for valid Tahoe node directory.
# If this stays we can remove a bunch of later checks.
check_tahoe_node

# Always check NEWS.html exists. Create a placeholder if it doesn't.
check_newshtml_exists

### Run selected actions ###

# Check if an obligatory option has been specified:
if [ $OPT_MERGE_LIST ] || [ $OPT_REPLACE_LIST ] || \
[ $OPT_REPAIR_SUBSCRIPTIONS ] || [ $OPT_DOWNLOAD_NEWS ] || \
[ $OPT_CHECK_VERSION ] || [ $OPT_DOWNLOAD_UPDATE ];
then
	[ $OPT_REPAIR_SUBSCRIPTIONS ] && repair_subscriptions
	# Make sure no conflicting options have been specified:
	if [ $OPT_MERGE_LIST ] && [ ! $OPT_REPLACE_LIST ]; then
		merge_list
	elif [ ! $OPT_MERGE_LIST ] && [ $OPT_REPLACE_LIST ]; then
		replace_list
	elif [ $OPT_MERGE_LIST ] && [ $OPT_REPLACE_LIST ]; then
		echo "ERROR: --merge-introducers and --replace-introducers are mutually exclusive." >&2
		print_help
		exit 1
	fi
	[ $OPT_DOWNLOAD_NEWS ] && download_news
	# Only run download_update if both --check-version and --download-update
	# have been specified:
	if [ $OPT_CHECK_VERSION ] && [ $OPT_DOWNLOAD_UPDATE ]; then
		download_update
	elif [ $OPT_DOWNLOAD_UPDATE ]; then
		download_update
	elif [ $OPT_CHECK_VERSION ]; then
		check_version
	fi
else
	echo "ERROR: You need to specify an action." >&2
	print_help
	exit 1
fi

exit 0
